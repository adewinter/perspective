<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - portal</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link type="text/css" rel="stylesheet" href="main.css">
        <style>
            body {
                color: #444;
            }
            a {
                color: #08f;
            }

            #info {
                color: white;
                position:  absolute;
            }
        </style>
    </head>
    <body>

        <div id="info"><a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - portal
            <h1></h1>
            <div>Camera: <pre id="campos">foo</pre></div>
            <div>RelBot: <pre id="bottomrelpos">bar</pre></div>
            <div>RelTop: <pre id="toprelpos">bash</pre></div>

        </div>
        <div id="container"></div>

        <!-- Import maps polyfill -->
        <!-- Remove this when import maps will be widely supported -->
        <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

        <script type="importmap">
            {
                "imports": {
                    "three": "./node_modules/three/build/three.module.js"
                }
            }
        </script>

        <script type="module">

            import * as THREE from 'three';

            import * as CameraUtils from './node_modules/three/examples/jsm/utils/CameraUtils.js';
            import { OrbitControls } from './node_modules/three/examples/jsm/controls/OrbitControls.js';
            import { FlyControls } from './node_modules/three/examples/jsm/controls/FlyControls.js';


            import Stats from './node_modules/three/examples/jsm/libs/stats.module.js';
            import { GUI } from './node_modules/three/examples/jsm/libs/lil-gui.module.min.js';

            let camera, scene, renderer;

            let cameraControls;

            let smallSphereOne, smallSphereTwo;

            let box, torus;

            let portalCamera, topPortal, bottomPortal, topPortalTexture, reflectedPosition,
                bottomPortalTexture, bottomLeftCorner, bottomRightCorner, topLeftCorner;

            let blc, brc, tlc;

            let portalCameraHelper, cameraHelper;

            let mainRoom, portalRoom;

            const clock = new THREE.Clock();
            const campostext = document.querySelector('#campos');
            const bottomrelpostext = document.querySelector('#bottomrelpos');
            const toprelpostext = document.querySelector('#toprelpos')
            let stats;
            init();
            animate();

            function doGUI() {
                const gui = new GUI();
                const corners = gui.addFolder('corners');
                const blcCorner = corners.addFolder('bottom-left-corner');
                blcCorner.add(blc, 'x', -52.0, 52.0);
                blcCorner.add(blc, 'y', -52.0, 52.0);
                blcCorner.add(blc, 'z', -52.0, 52.0);

                const brcCorner = corners.addFolder('bottom-right-corner');
                brcCorner.add(brc, 'x', -52.0, 52.0);
                brcCorner.add(brc, 'y', -52.0, 52.0);
                brcCorner.add(brc, 'z', -52.0, 52.0);

                const tlcCorner = corners.addFolder('top-left-corner');
                tlcCorner.add(tlc, 'x', -52.0, 52.0);
                tlcCorner.add(tlc, 'y', -52.0, 52.0);
                tlcCorner.add(tlc, 'z', -52.0, 52.0);

            }

            // function

            function init() {

                const container = document.getElementById( 'container' );
                stats = new Stats();
                document.body.appendChild( stats.dom );


                blc = new THREE.Vector3(  50.05, - 50.05, 0.0 );
                brc = new THREE.Vector3(- 50.05, - 50.05, 0.0);
                tlc = new THREE.Vector3(50.05, 50.05, 0.0);
                // renderer
                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                container.appendChild( renderer.domElement );
                renderer.localClippingEnabled = true;

                // scene
                scene = new THREE.Scene();

                // camera
                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 5000 );
                camera.position.set( 0, 75, 160 );

                // cameraHelper = new THREE.CameraHelper(camera)
                // scene.add(cameraHelper);

                // cameraControls = new OrbitControls( camera, renderer.domElement );
                // cameraControls.target.set( 0, 40, 0 );
                // cameraControls.maxDistance = 400;
                // cameraControls.minDistance = 10;
                // cameraControls.update();


                cameraControls = new FlyControls( camera, renderer.domElement );

                cameraControls.movementSpeed = 50;
                cameraControls.domElement = renderer.domElement;
                cameraControls.rollSpeed = Math.PI / 2;
                cameraControls.autoForward = false;
                cameraControls.dragToLook = true;

                //

                

                const planeGeo = new THREE.PlaneGeometry( 100.1, 100.1 );

                // bouncing icosphere
                const portalPlane = new THREE.Plane( new THREE.Vector3( 0, 0, 1 ), 0.0 );
                const geometry = new THREE.IcosahedronGeometry( 5, 0 );
                const material = new THREE.MeshPhongMaterial( {
                    color: 0xffffff, emissive: 0x333333, flatShading: true,
                    /* clippingPlanes: [ portalPlane ], */clipShadows: true } );
                smallSphereOne = new THREE.Mesh( geometry, material );
                const foo = new THREE.Mesh(geometry, material);
                foo.position.set(0,0,0);
                scene.add(foo);
                // scene.add( smallSphereOne );
                smallSphereTwo = new THREE.Mesh( geometry, material );
                // scene.add( smallSphereTwo );

                // portals
                portalCamera = new THREE.PerspectiveCamera( 45, 1.0, 0.1, 500.0 );
                scene.add( portalCamera );
                portalCameraHelper = new THREE.CameraHelper( portalCamera );
                scene.add( portalCameraHelper );
                bottomLeftCorner = new THREE.Vector3();
                bottomRightCorner = new THREE.Vector3();
                topLeftCorner = new THREE.Vector3();
                reflectedPosition = new THREE.Vector3();

                topPortalTexture = new THREE.WebGLRenderTarget( 256, 256 );
                const transparentMat = new THREE.MeshBasicMaterial({opacity: 0.0, wireframe: true});
                const wireMat = new THREE.MeshBasicMaterial( {

                        color: 0xe0e0ff,
                        wireframe: true

                    } );
                // topPortal = new THREE.Mesh( planeGeo, new THREE.MeshBasicMaterial( { map: topPortalTexture.texture } ) );
                topPortal = new THREE.Mesh( planeGeo, new THREE.MeshBasicMaterial(transparentMat) );

                // topPortal = new THREE.Mesh( planeGeo, wireMat );
                // topPortal = new THREE.Point();
                // topPortal.position.x = - 30;
                topPortal.position.z = 70;
                topPortal.position.y = 168;
                topPortal.scale.set( 0.01, 0.01, 0.01 );
                scene.add( topPortal );

                bottomPortalTexture = new THREE.WebGLRenderTarget( 256, 256 );
                bottomPortal = new THREE.Mesh( planeGeo, new THREE.MeshBasicMaterial( { map: bottomPortalTexture.texture } ) );
                // bottomPortal.position.x = 30;
                bottomPortal.position.y = 20;
                bottomPortal.scale.set( 0.35, 0.35, 0.35 );
                scene.add( bottomPortal );


                mainRoom = new THREE.Group();
                // walls
                const planeTop = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xffffff } ) );
                planeTop.position.y = 100;
                planeTop.rotateX( Math.PI / 2 );
                mainRoom.add( planeTop );

                const planeBottom = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xffffff } ) );
                planeBottom.rotateX( - Math.PI / 2 );
                mainRoom.add( planeBottom );

                const planeFront = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x7f7fff } ) );
                planeFront.position.z = 50;
                planeFront.position.y = 50;
                planeFront.rotateY( Math.PI );
                mainRoom.add( planeFront );

                const planeBack = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xff7fff } ) );
                planeBack.position.z = - 50;
                planeBack.position.y = 50;
                //planeBack.rotateY( Math.PI );
                mainRoom.add( planeBack );

                const planeRight = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0x00ff00 } ) );
                planeRight.position.x = 50;
                planeRight.position.y = 50;
                planeRight.rotateY( - Math.PI / 2 );
                mainRoom.add( planeRight );

                const planeLeft = new THREE.Mesh( planeGeo, new THREE.MeshPhongMaterial( { color: 0xff0000 } ) );
                planeLeft.position.x = - 50;
                planeLeft.position.y = 50;
                planeLeft.rotateY( Math.PI / 2 );
                mainRoom.add( planeLeft );



                // lights
                const mainLight = new THREE.PointLight( 0xcccccc, 1.5, 250 );
                mainLight.position.y = 60;
                mainRoom.add( mainLight );

                const greenLight = new THREE.PointLight( 0x00ff00, 0.25, 1000 );
                greenLight.position.set( 550, 50, 0 );
                mainRoom.add( greenLight );

                const redLight = new THREE.PointLight( 0xff0000, 0.25, 1000 );
                redLight.position.set( - 550, 50, 0 );
                mainRoom.add( redLight );

                const blueLight = new THREE.PointLight( 0x7f7fff, 0.25, 1000 );
                blueLight.position.set( 0, 50, 550 );
                mainRoom.add( blueLight );

                scene.add(mainRoom);

                //portal Rooom
                portalRoom = mainRoom.clone()
                portalRoom.position.y = 150;

                const boxGeo = new THREE.BoxGeometry(10.0, 10.0, 10);
                const boxMat = new THREE.MeshPhongMaterial( { color: 0x00ff00 } );
                box = new THREE.Mesh( boxGeo, boxMat );
                box.position.y = 5;
                portalRoom.add(box);

                const torusGeo = new THREE.TorusKnotGeometry( 4, 0.8, 95, 20 );
                const torusMat = new THREE.MeshPhongMaterial( {
                    color: 0x80ee10,
                    shininess: 100,
                    side: THREE.DoubleSide
                });

                torus = new THREE.Mesh( torusGeo, torusMat );
                torus.castShadow = true;
                torus.position.y = 20;
                portalRoom.add(torus);

                scene.add(portalRoom);

                window.addEventListener( 'resize', onWindowResize );

                doGUI();

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function vecToString(vec) {
                return 'x:' + vec.x.toFixed() + ',\ty:' + vec.y.toFixed() + ',\tz:' + vec.z.toFixed();
            }

            function renderPortal( thisPortalMesh, otherPortalMesh, thisPortalTexture ) {

                // set the portal camera position to be reflected about the portal plane
                // console.log(reflectedPosition);
                
                //copies the position of the main camera into `reflectedPosition`
                reflectedPosition.copy( camera.position )
                campostext.innerText = vecToString(camera.position);

                //converts `reflectedPostion` coordinates from world relative to thisPortalMesh.position relative
                thisPortalMesh.worldToLocal( reflectedPosition );
                
                let pRelToBottomMesh = new THREE.Vector3();
                pRelToBottomMesh.copy(reflectedPosition);
                bottomrelpostext.innerText = vecToString(pRelToBottomMesh);

                //flip things about their axis?
                // reflectedPosition.x *= - 1.0; 
                // reflectedPosition.z *= - 1.0;

                //convert coordinates from thisPortalMesh.position relative to otherPortalMesh.position relative
                otherPortalMesh.localToWorld( reflectedPosition );

                toprelpostext.innerText = vecToString(reflectedPosition);

                let pRelToTopMesh = new THREE.Vector3();
                pRelToTopMesh.copy(reflectedPosition);

                //set the portalCamera position eql to reflectedPosition coords
                portalCamera.position.copy( reflectedPosition );

                // grab the corners of the other portal
                // - note: the portal is viewed backwards; flip the left/right coordinates
                // otherPortalMesh.localToWorld( bottomLeftCorner.copy( blc ) );
                // otherPortalMesh.localToWorld( bottomRightCorner.copy( brc ) );
                // otherPortalMesh.localToWorld( topLeftCorner.copy( tlc ) );
                // set the projection matrix to encompass the portal's frame
                // CameraUtils.frameCorners( portalCamera, bottomLeftCorner, bottomRightCorner, topLeftCorner, true );

                // render the portal
                thisPortalTexture.texture.encoding = renderer.outputEncoding;
                renderer.setRenderTarget( thisPortalTexture );
                renderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897
                if ( renderer.autoClear === false ) renderer.clear();
                // thisPortalMesh.visible = false; // hide this portal from its own rendering
                renderer.render( scene, portalCamera );
                thisPortalMesh.visible = true; // re-enable this portal's visibility for general rendering

            }

            function animate() {

                requestAnimationFrame( animate );
                const delta = clock.getDelta();
                cameraControls.update( delta );

                // box.position.copy(portalCamera.position);

                // move the bouncing sphere(s)
                const timerOne = Date.now() * 0.01;
                const timerTwo = timerOne + Math.PI * 10.0;
                const timerThree = timerOne * 0.1;

                // torus.position.y = 0.8;
                torus.rotation.x = timerThree * 0.5;
                torus.rotation.y = timerThree * 0.2;
                torus.scale.setScalar( Math.cos( timerThree ) * 0.125 + 0.875 );

                smallSphereOne.position.set(
                    Math.cos( timerOne * 0.1 ) * 30,
                    Math.abs( Math.cos( timerOne * 0.2 ) ) * 20 + 5,
                    Math.sin( timerOne * 0.1 ) * 30
                );
                smallSphereOne.rotation.y = ( Math.PI / 2 ) - timerOne * 0.1;
                smallSphereOne.rotation.z = timerOne * 0.8;

                smallSphereTwo.position.set(
                    Math.cos( timerTwo * 0.1 ) * 30,
                    Math.abs( Math.cos( timerTwo * 0.2 ) ) * 20 + 5,
                    Math.sin( timerTwo * 0.1 ) * 30
                );
                smallSphereTwo.rotation.y = ( Math.PI / 2 ) - timerTwo * 0.1;
                smallSphereTwo.rotation.z = timerTwo * 0.8;

                // save the original camera properties
                const currentRenderTarget = renderer.getRenderTarget();
                const currentXrEnabled = renderer.xr.enabled;
                const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
                renderer.xr.enabled = false; // Avoid camera modification
                renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows

                // render the portal effect
                // renderPortal( topPortal, bottomPortal, topPortalTexture );
                renderPortal( bottomPortal, topPortal, bottomPortalTexture );

                // restore the original rendering properties
                renderer.xr.enabled = currentXrEnabled;
                renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
                renderer.setRenderTarget( currentRenderTarget );

                // render the main scene
                renderer.render( scene, camera );
                stats.update();

            }

        </script>
    </body>
</html>
